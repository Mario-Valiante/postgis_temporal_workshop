<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
  <title>big</title>
  <link href='big.css' rel='stylesheet' type='text/css' />
  <link href='highlight.css' rel='stylesheet' type='text/css' />
  <style>
    .new-shiny { background: #aaaaaa; }
  </style>
  <script src='big.js'></script>
  <script src='highlight.js'></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body class='light'>
  <div><h1 id="breaking-the-4th-dimension-working-with-time-in-postgresql-and-postgis">Breaking the 4th dimension: working with time in PostgreSQL and PostGIS</h1>
</div>
<div><p><img src="https://pbs.twimg.com/profile_images/779351896817602562/YXf-qdul.jpg" width="100%"></p>
</div>
<div><h3 id="david-bitner-dbitner-boundlessgeo-com">David Bitner dbitner@boundlessgeo.com</h3>
<p>Senior Development Engineer - Boundless Spatial <img src="https://boundlessgeo.com/wp-content/themes/boundlessgeo/assets/images/BoundlessLogoTag.svg" alt=""></p>
</div>
<div><p>The goal of this workshop is to walk through several examples of how to use 3rd and 4th dimension data with PostgreSQL and PostGIS with a particular emphasis on using M values with points and linestrings.</p>
</div>
<div><p>PostgreSQL has very extensive support for temporal data using the Timestamp, TimestampTZ, Date, Time, TimeTZ, and Interval data types. PostgreSQL is very forgiving as to how data can be input as plain text.</p>
<p>It should be noted that in almost all cases it is better to use the Time Zone aware TimestampTZ and TimeTZ data types as the non timezone aware Timestamp and Time can be lossy and ambiguous in most circumstances. </p>
<p>Further, while PostgreSQL is incredibly tolerant of text data input formats, ISO8601 should be the preferred method for communicating with dates and times. Day/month/year and month/day/year can be particularly problematic as they are each preferred in different parts of the world.</p>
<pre><code class="lang-sql">SELECT &#39;2017-01-01 00:00-6&#39;::timestamptz;

SELECT &#39;2017-01-01&#39;::timestamptz;

SELECT &#39;4/5/2017&#39;::timestamptz;
</code></pre>
</div>
<div><p>Day/month/year and month/day/year can be particularly problematic as they are each preferred in different parts of the world.</p>
<pre><code class="lang-sql">SET datestyle to dmy;
SELECT &#39;4/5/2017&#39;::timestamptz;

SET datestyle TO DEFAULT;
SELECT &#39;4/5/2017&#39;::timestamptz;
</code></pre>
<p>By using the TimestampTZ data type it becomes easy to view the data in whatever locality is necessary at the moment.</p>
<pre><code class="lang-sql">SELECT now();
SET TIME ZONE &#39;Europe/Rome&#39;;
SELECT now();

SET TIME ZONE &#39;UTC&#39;;
SELECT now();

SET TIME ZONE &#39;PST8PDT&#39;;
SELECT now();

SET TIME ZONE DEFAULT;
SHOW TIME ZONE;
SELECT now();

SELECT timezone(&#39;UTC&#39;, now());
</code></pre>
<p>PostgreSQL also has an interval type that can maintain periods of time</p>
<pre><code class="lang-sql">SELECT &#39;1 day&#39;::interval;
SELECT &#39;2016-01-01&#39;::timestamptz + &#39;3 months&#39;::interval;
</code></pre>
<pre><code class="lang-sql">SELECT to_timestamp(0);

SELECT timezone(&#39;UTC&#39;,to_timestamp(0));

SELECT extract(epoch from &#39;2017-01-01&#39;::timestamptz);

SELECT extract(epoch from &#39;1 hour&#39;::interval);
</code></pre>
<pre><code class="lang-sql">
CREATE FUNCTION to_epoch(IN timestamptz, OUT float8) AS $$
    SELECT extract(epoch from $1);
$$ LANGUAGE SQL;

CREATE FUNCTION to_epoch(IN interval, OUT float8) AS $$
    SELECT extract(epoch from $1);
$$ LANGUAGE SQL;

SELECT to_epoch(&#39;2017-01-01&#39;::timestamptz);
SELECT to_epoch(&#39;1 hour&#39;::interval);
</code></pre>
<pre><code class="lang-sql">
SELECT date_trunc(&#39;month&#39;, now());
</code></pre>
<pre><code class="lang-sql">
SELECT &#39;4713-01-01 BC&#39;::timestamptz;
SELECT &#39;4714-01-01 BC&#39;::timestamptz;

SELECT &#39;294276-01-01&#39;::timestamptz;
SELECT &#39;294277-01-01&#39;::timestamptz;
</code></pre>
<pre><code class="lang-sql">
SELECT st_dumppoints(geom) FROM superior100 limit 10;
SELECT (st_dumppoints(geom)).* FROM superior100 limit 10;
</code></pre>
<pre><code class="lang-sql">
WITH t AS (SELECT st_dumppoints(geom) as dump FROM superior100)
SELECT 
    (dump).path[1],
    st_asewkt((dump).geom), 
    st_x((dump).geom), 
    st_y((dump).geom)
FROM t 
LIMIT 10;
</code></pre>
<pre><code class="lang-sql">
DROP TABLE IF EXISTS superior100_points;
CREATE TABLE superior100_points AS 
WITH t AS (SELECT st_dumppoints(geom) as dump FROM superior100)
SELECT 
    (dump).path[1],
    (dump).geom, 
    st_x((dump).geom) as x, 
    st_y((dump).geom) as y
FROM t;
</code></pre>
<pre><code class="lang-sql">
ALTER TABLE superior100_points ADD COLUMN z float8;

UPDATE superior100_points 
SET 
    z=round(st_value(rast,geom)::numeric,1)
FROM dem 
WHERE st_intersects(dem.rast,geom);
</code></pre>
<pre><code class="lang-sql">
SELECT st_asewkt(geom), x, y, z FROM superior100_points LIMIT 10;

UPDATE superior100_points SET geom = st_setsrid(st_makepoint(x,y,z), 26915);
</code></pre>
<pre><code class="lang-sql">
SELECT st_asewkt(geom) FROM superior100_points LIMIT 10;

WITH t AS (SELECT * FROM superior100_points ORDER BY PATH)
SELECT substring(st_asewkt(st_makeline(geom)),1,100) FROM t;
</code></pre>
<pre><code class="lang-sql">
CREATE TABLE superior1003d AS
WITH t AS (SELECT * FROM superior100_points ORDER BY PATH)
SELECT st_makeline(geom) as geom FROM t;

SELECT path, x, y, z, z-lag(z) OVER (ORDER BY PATH) FROM superior100_points LIMIT 20;
</code></pre>
<pre><code class="lang-sql">
ALTER TABLE superior100_points ADD COLUMN elchange float8;

WITH t AS (SELECT path, x, y, z, round((z-lag(z) OVER (ORDER BY PATH))::numeric,1) elchange FROM superior100_points)
UPDATE superior100_points p SET elchange=t.elchange FROM t WHERE p.path=t.path;

SELECT x, y, z, elchange FROM superior100_points limit 10;
</code></pre>
<pre><code class="lang-sql">
SELECT 
    3.28 * sum(elchange) FILTER (WHERE elchange&gt;0) as gain, 
    3.28 * sum(elchange) FILTER (WHERE elchange&lt;0) as descent 
FROM superior100_points;
</code></pre>
<pre><code class="lang-sql">
SELECT path, x, y, z, degrees(st_azimuth(lag(geom) OVER (ORDER BY path), geom)) FROM superior100_points LIMIT 20;
</code></pre>
<pre><code class="lang-sql">

SELECT st_length(geom)/1609 FROM superior100;
SELECT st_length(geom)/1609 FROM superior1003d;
SELECT st_3dlength(geom)/1609 FROM superior1003d;
</code></pre>
<pre><code class="lang-sql">

SELECT st_asewkt(st_lineinterpolatepoint(geom,.5)) FROM superior1003d;
SELECT st_asewkt(st_lineinterpolatepoint(geom,50*1609/st_length(geom))) FROM superior1003d;

SELECT
    a.aidstation,
    a.miles,
    a.miles/st_length(s.geom)*1609 as along_track,
    a.miles/103.2 along_total_distance,
    st_linelocatepoint(s.geom,a.geom) at_nearest_point
FROM
    aidstations a,
    superior1003d s
ORDER BY a.miles
;

CREATE TABLE sections AS
SELECT 
    aidstation,
    miles,
    st_addmeasure(
        st_linesubstring(
            s.geom,
            st_linelocatepoint(s.geom,lag(a.geom) OVER (ORDER BY miles)),
            st_linelocatepoint(s.geom,a.geom)
        ),
        lag(a.miles) OVER (ORDER BY miles),
        a.miles
    ) as geom
FROM
    aidstations a,
    superior1003d s
ORDER BY a.miles  
;

SELECT aidstation, miles, substring(st_asewkt(geom),0,100) FROM sections;

CREATE TABLE superior1003dm AS 
SELECT st_linemerge(st_collect(geom)) AS geom FROM sections;

SELECT substring(st_asewkt(geom),0,100) FROM superior1003dm;

DROP TABLE superior1003dm;
CREATE TABLE superior1003dm AS 
WITH 
p1 AS 
    (SELECT (st_dumppoints(geom)).* FROM sections),
p2 AS
    (SELECT geom, st_m(geom) FROM p1 ORDER BY st_m(geom))
SELECT st_makeline(geom) as geom FROM p2;

SELECT substring(st_asewkt(geom),0,100) FROM superior1003dm;

SELECT * FROM superiorsplits ORDER BY runnerid, aidstation LIMIT 20;

SELECT aidstation, min(split), avg(split), max(split) FROM superiorsplits GROUP BY aidstation ORDER BY min(split);

SELECT aidstation, min(split), avg(split), max(split) 
FROM superiorsplits 
WHERE finish BETWEEN &#39;35 hours&#39;::interval AND &#39;37 hours&#39;::interval
GROUP BY aidstation ORDER BY min(split);

CREATE TABLE bitner_goal AS 
WITH 
goalsplits AS (
    SELECT aidstation, avg(split) as goal
    FROM superiorsplits 
    WHERE finish BETWEEN &#39;35 hours&#39;::interval AND &#39;37 hours&#39;::interval
    GROUP BY aidstation ORDER BY min(split)
)
SELECT 
    aidstation,
    miles as miles,
    miles - coalesce(lag(miles) OVER (ORDER BY miles),0) AS miles_section,
    coalesce(lag(goal) OVER (ORDER BY miles),&#39;0 hours&#39;::interval) as goal_from,
    goal as goal_to,
    goal - coalesce(lag(goal) OVER (ORDER BY miles),&#39;0 hours&#39;::interval) AS goal_section,
    &#39;2017-09-08 08:00:00 CDT&#39;::timestamptz + goal AS goal_time,
    (goal - coalesce(lag(goal) OVER (ORDER BY miles),&#39;0 hours&#39;::interval)) 
    /  
    (miles - coalesce(lag(miles) OVER (ORDER BY miles),0))
    as pace_section
FROM
    sections JOIN goalsplits USING (aidstation)
;

SELECT * FROM bitner_goal;

CREATE TABLE bitner_goal_track AS
WITH
t1 AS (
    SELECT 
        st_addmeasure(geom, to_epoch(goal_from), to_epoch(goal_to)) AS geom
    FROM
        sections JOIN bitner_goal USING (aidstation)
),
p1 AS 
    (SELECT (st_dumppoints(geom)).* FROM t1),
p2 AS
    (SELECT DISTINCT ON (st_m(geom)) geom, st_m(geom) FROM p1 ORDER BY st_m(geom))
SELECT st_makeline(geom) as geom FROM p2;

SELECT substring(st_asewkt(geom),0,100) FROM bitner_goal_track;

SELECT * FROM superiorsplits 
WHERE aidstation=&#39;finish&#39; AND finish BETWEEN &#39;35.5 hours&#39;::interval AND &#39;36.5 hours&#39;::interval LIMIT 20;

CREATE TABLE target_goal AS 
WITH 
goalsplits AS (
    SELECT aidstation, split as goal
    FROM superiorsplits 
    WHERE runnerid = 93
)
SELECT 
    aidstation,
    miles as miles,
    miles - coalesce(lag(miles) OVER (ORDER BY miles),0) AS miles_section,
    coalesce(lag(goal) OVER (ORDER BY miles),&#39;0 hours&#39;::interval) as goal_from,
    goal as goal_to,
    goal - coalesce(lag(goal) OVER (ORDER BY miles),&#39;0 hours&#39;::interval) AS goal_section,
    &#39;2017-09-08 08:00:00 CDT&#39;::timestamptz + goal AS goal_time,
    (goal - coalesce(lag(goal) OVER (ORDER BY miles),&#39;0 hours&#39;::interval)) 
    /  
    (miles - coalesce(lag(miles) OVER (ORDER BY miles),0))
    as pace_section
FROM
    sections JOIN goalsplits USING (aidstation)
;

SELECT * FROM target_goal;

CREATE TABLE target_goal_track AS
WITH
t1 AS (
    SELECT 
        st_addmeasure(geom, to_epoch(goal_from), to_epoch(goal_to)) AS geom
    FROM
        sections JOIN target_goal USING (aidstation)
),
p1 AS 
    (SELECT (st_dumppoints(geom)).* FROM t1),
p2 AS
    (SELECT DISTINCT ON (st_m(geom)) geom, st_m(geom) FROM p1 ORDER BY st_m(geom))
SELECT st_makeline(geom) as geom FROM p2;

SELECT substring(st_asewkt(geom),0,100) FROM target_goal_track;

SELECT st_isvalidtrajectory(geom) FROM bitner_goal_track;
SELECT st_isvalidtrajectory(geom) FROM target_goal_track;

SELECT (st_closestpointofapproach(
    (SELECT st_linesubstring(geom,.5,1) FROM bitner_goal_track),
    (SELECT st_linesubstring(geom,.5,1) FROM target_goal_track)
)::text || &#39; seconds&#39;)::interval;

SELECT st_distancecpa(
    (SELECT st_linesubstring(geom,.5,1) FROM bitner_goal_track),
    (SELECT st_linesubstring(geom,.5,1) FROM target_goal_track)
);
</code></pre>
</div>
</body>
</html>
